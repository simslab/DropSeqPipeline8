#! /usr/bin/python3.4
import sys
from numpy import count_nonzero,array

# The purpose of this program is to collapse cell barcodes that are likely generated by sequencing error. The program
# takes advantage of the fact that cell barcode sequences separated by a short edit distance and with significant 
# overlap in the identities of associated molecules (as inferred from gene alignment and UMI sequence) likely 
# correspond to the same cell barcode sequence.  It is assumed that cell barcodes with higher coverage are more
# likley to be correct.

filt_INFILE = sys.argv[1] # program operates on filtered molecule counts
cfilt_OUTFILE = sys.argv[2] # output
molecule_CUTOFF = int(sys.argv[3]) # minimum number of molecules associated with a barcode under consideration
overlap_CUTOFF = float(sys.argv[4]) # minimum fractional overlap required for two barcodes to be collapsed
trackbcs_INFILE = sys.argv[5] # file tracking cell barcode collapse from incomplete extension (output of DropSeqPipeline6_collapse.py)
trackbcs_OUTFILE = sys.argv[6] # final cell barcode alteration tracking output

print('Loading...')
cellbcs = {} # dictionary containing cell barcode sequence keys and a string containing the UMI and gene as values
cellbcsct = {} # dictionary containing cell barcode sequence keys and the number of counts as values
with open(filt_INFILE) as f:
	for line in f:
		llist = line.split()
		cellbc = llist[0]
		umigene = llist[1]+':'+llist[2] # UMI:gene contatenated molecule identifier
		if cellbc in cellbcs:
			cellbcs[cellbc].append(umigene) 
			cellbcsct[cellbc].append(llist[3])
		else:
			cellbcs[cellbc] = [umigene]
			cellbcsct[cellbc] = [llist[3]]

print('Filtering...')
cellbcL = {} # dictionary containing cell barcode sequence keys and number of associated molecules as values
for cellbc in cellbcs.keys():
	L = len(cellbcs[cellbc])
	if L >= molecule_CUTOFF: # enforce minimum number of molecules so that fractional overlap can be accurately assessed
		cellbcL[cellbc] = L

print('Sorting...')
cellbcL_sort = sorted(cellbcL, key=lambda k:cellbcL[k], reverse=True) # sort cell barcodes by number of associated molecules
N = len(cellbcL_sort)
cellbcs_test = [array(list(cellbc)) for cellbc in cellbcL_sort] # convert sorted cell barcode sequences to numpy arrays for Hamming calculation
oldcellbc_list = [cellbc for cellbc in cellbcs.keys()] 
cellbcs_sets = {}
for cellbc in oldcellbc_list:
	if cellbc not in cellbcL: # remove coverage-filtered cell barcodes
		del cellbcs[cellbc]
		del cellbcsct[cellbc] 
	else:                     # create set of kept cell barcodes
		cellbcs_sets[cellbc] = set(cellbcs[cellbc])

print(N)
print('Collapsing...')
i=0
collapsed=set() # keep track of collapsed cell barcodes
alteredbcs = [] # list of tuples of old,new cell barcodes
for cellbc in cellbcL_sort: # loop through cell barcodes in descending order of coverage
	print(i,N-len(collapsed),end='\r')
	if i not in collapsed: # if the cell barcode hasn't already been collapsed
		umigenes = cellbcs_sets[cellbc] # list of molecules
		cellbctest = cellbcs_test[i]    # numpy array of cell barcode seqeunce
		L = len(cellbc)
		ct = 3*L # maximum number of H=1 cell barcodes
		k = 0
		for j in range(i+1,N):  # loop through all lower coverage barcodes
			if j not in collapsed: # if the cell barcode hasn't already been collapsed
				cellbc2 = cellbcL_sort[j] 
				if len(cellbc2) == L: # if two cell barcode sequences have the same number of nts
					cellbctest2 = cellbcs_test[j] # get the numpy array version of cellbc2
					if count_nonzero(cellbctest!=cellbctest2) == 1: # if Hamming distance is one
						k+=1
						umigenes2 = cellbcs_sets[cellbc2] # get the molecules associated with cellbc2
						overlap = float(len(umigenes.intersection(umigenes2)))/float(len(umigenes2)) # compute fractional overlap in molecules
						if overlap >= overlap_CUTOFF: # if there's a lot of overlap, then they're the same cell barcode and should be collapsed
							cellbcs[cellbc].extend(cellbcs[cellbc2]) # extend high-coverage barcode with molecules from low-coverage barcode
							cellbcsct[cellbc].extend(cellbcsct[cellbc2])
							del cellbcs[cellbc2] # remove low-coverage barcode
							del cellbcsct[cellbc2]
							collapsed.add(j)
							alteredbcs.append((cellbc2,cellbc)) # keep track of change in cell barcode sequence
			if k == ct: # if we've reached the maximum number of H=1 cell barcodes, stop searching
				break
	i+=1

print('Writing...')
with open(cfilt_OUTFILE,'w') as g:
	i=0
	for cellbc in cellbcs.keys(): # output collapsed cell barcode molecules
		for umigene,ct in zip(cellbcs[cellbc],cellbcsct[cellbc]):
			st = cellbc+'\t'+umigene.split(':')[0]+'\t'+umigene.split(':')[1]+'\t'+ct+'\n'
			g.write(st)
		i+=1
					
				
print('Tracking altered barcodes...')
old_alteredbcs = {}
with open(trackbcs_INFILE) as h:
	for line in h: # get original cell barcode sequences from incomplete extension collapse
		llist = line.split()
		old_alteredbcs[llist[1]] = llist[0]

with open(trackbcs_OUTFILE,'w') as z: # output the old and new cell barcode sequences for all collapsed cell barcodes
	oldoldbcs = set()
	for alteredbc in alteredbcs:
		oldbc = alteredbc[0] 
		newbc = alteredbc[1]
		if oldbc not in old_alteredbcs.keys():
			z.write('%(oldbc)s\t%(newbc)s\n' % vars())
		else:
			oldoldbc = old_alteredbcs[oldbc]
			oldoldbcs.add(oldbc)
			z.write('%(oldoldbc)s\t%(newbc)s\n' % vars())
	for old_alteredbc in old_alteredbcs.keys(): # add back any un-collapsed barcodes that were collapsed in DropSeqPipeline6_collapse.py but not here
		if old_alteredbc not in oldoldbcs:
			oldoldbc = old_alteredbcs[old_alteredbc]
			z.write('%(oldoldbc)s\t%(old_alteredbc)s\n' % vars())





	
